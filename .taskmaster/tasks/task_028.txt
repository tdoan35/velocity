# Task ID: 28
# Title: Implement Unified Context Provider System for Navigation
# Status: done
# Dependencies: 14, 27
# Priority: medium
# Description: Fix navigation refresh issues between Project Design and Editor pages by implementing a unified context provider system that prevents component tree remounting when navigating between /project/{id} and /project/{id}/editor routes.
# Details:
## Implementation Details

1. **Analyze Current Context Provider Architecture**
   - Identify the existing ProjectProvider and SecurityProvider implementations
   - Document the current state management approach and data flow
   - Map out component remounting issues during navigation
   - Measure current navigation performance metrics as baseline

2. **Design Unified Context Provider System**
   - Create a new `UnifiedProjectProvider` component that combines functionality:
   ```tsx
   // src/providers/UnifiedProjectProvider.tsx
   import React, { createContext, useContext, useState, useEffect, useMemo } from 'react';
   import { useParams } from 'react-router-dom';
   import { supabase } from '../lib/supabaseClient';
   
   interface UnifiedProjectContextType {
     project: Project | null;
     security: SecuritySettings | null;
     loading: boolean;
     error: Error | null;
     refreshProject: () => Promise<void>;
     updateSecurity: (settings: Partial<SecuritySettings>) => Promise<void>;
     // Additional methods as needed
   }
   
   const UnifiedProjectContext = createContext<UnifiedProjectContextType | undefined>(undefined);
   
   export const UnifiedProjectProvider: React.FC = ({ children }) => {
     const { id } = useParams<{ id: string }>();
     const [project, setProject] = useState<Project | null>(null);
     const [security, setSecurity] = useState<SecuritySettings | null>(null);
     const [loading, setLoading] = useState<boolean>(true);
     const [error, setError] = useState<Error | null>(null);
     
     // Implement data fetching with caching
     // ...
     
     const contextValue = useMemo(() => ({
       project,
       security,
       loading,
       error,
       refreshProject,
       updateSecurity,
     }), [project, security, loading, error]);
     
     return (
       <UnifiedProjectContext.Provider value={contextValue}>
         {children}
       </UnifiedProjectContext.Provider>
     );
   };
   
   export const useUnifiedProject = () => {
     const context = useContext(UnifiedProjectContext);
     if (context === undefined) {
       throw new Error('useUnifiedProject must be used within a UnifiedProjectProvider');
     }
     return context;
   };
   ```

3. **Implement State Caching Mechanism**
   - Create a project state cache using React Context API
   - Implement cache invalidation strategy based on project updates
   - Add cache hit/miss tracking for performance monitoring
   - Use localStorage for persistent caching between sessions:
   ```tsx
   // Cache implementation within UnifiedProjectProvider
   const [cache, setCache] = useState<Record<string, CachedData>>(() => {
     const savedCache = localStorage.getItem('projectCache');
     return savedCache ? JSON.parse(savedCache) : {};
   });
   
   useEffect(() => {
     localStorage.setItem('projectCache', JSON.stringify(cache));
   }, [cache]);
   
   const fetchProjectData = async (projectId: string) => {
     // Check cache first
     if (cache[projectId] && Date.now() - cache[projectId].timestamp < CACHE_TTL) {
       setProject(cache[projectId].project);
       setSecurity(cache[projectId].security);
       setLoading(false);
       return;
     }
     
     // Fetch from API if not in cache
     try {
       setLoading(true);
       const [projectData, securityData] = await Promise.all([
         fetchProject(projectId),
         fetchSecurity(projectId)
       ]);
       
       setProject(projectData);
       setSecurity(securityData);
       
       // Update cache
       setCache(prev => ({
         ...prev,
         [projectId]: {
           project: projectData,
           security: securityData,
           timestamp: Date.now()
         }
       }));
     } catch (err) {
       setError(err as Error);
     } finally {
       setLoading(false);
     }
   };
   ```

4. **Optimize API Call Reduction**
   - Implement debounced API calls to prevent redundant requests
   - Add conditional fetching based on data staleness
   - Implement optimistic UI updates for immediate feedback
   - Use React Query or SWR for advanced caching:
   ```tsx
   import { useQuery, useMutation, useQueryClient } from 'react-query';
   
   // Within UnifiedProjectProvider
   const queryClient = useQueryClient();
   
   const { data: projectData, isLoading: projectLoading } = useQuery(
     ['project', id],
     () => fetchProject(id as string),
     {
       staleTime: 5 * 60 * 1000, // 5 minutes
       cacheTime: 10 * 60 * 1000, // 10 minutes
       enabled: !!id
     }
   );
   
   const updateProjectMutation = useMutation(
     (updates: Partial<Project>) => updateProject(id as string, updates),
     {
       onMutate: async (newData) => {
         // Optimistic update
         await queryClient.cancelQueries(['project', id]);
         const previousData = queryClient.getQueryData(['project', id]);
         queryClient.setQueryData(['project', id], old => ({
           ...old,
           ...newData
         }));
         return { previousData };
       },
       onError: (err, newData, context) => {
         // Roll back on error
         queryClient.setQueryData(['project', id], context?.previousData);
       },
       onSettled: () => {
         // Refetch to ensure consistency
         queryClient.invalidateQueries(['project', id]);
       }
     }
   );
   ```

5. **Implement Navigation Performance Optimizations**
   - Add route-based code splitting for faster page loads
   - Implement transition states to prevent UI flicker
   - Use React.memo and useMemo for component optimization
   - Add skeleton loaders for perceived performance improvement:
   ```tsx
   // In route components
   import { Suspense, lazy } from 'react';
   
   const ProjectDesign = lazy(() => import('./ProjectDesign'));
   const ProjectEditor = lazy(() => import('./ProjectEditor'));
   
   // In router setup
   <Route path="/project/:id">
     <UnifiedProjectProvider>
       <Suspense fallback={<SkeletonLoader type="project" />}>
         <Route exact path="/project/:id" component={ProjectDesign} />
         <Route path="/project/:id/editor" component={ProjectEditor} />
       </Suspense>
     </UnifiedProjectProvider>
   </Route>
   ```

6. **Update Router Configuration**
   - Modify the application router to use the UnifiedProjectProvider
   - Ensure the provider wraps both project routes
   - Implement shallow routing for navigation between pages
   - Add route transition animations for smoother UX:
   ```tsx
   // src/App.tsx or router configuration
   import { BrowserRouter, Routes, Route } from 'react-router-dom';
   import { UnifiedProjectProvider } from './providers/UnifiedProjectProvider';
   import { AnimatePresence } from 'framer-motion';
   
   function App() {
     return (
       <BrowserRouter>
         <Routes>
           {/* Other routes */}
           <Route 
             path="/project/:id/*" 
             element={
               <UnifiedProjectProvider>
                 <AnimatePresence mode="wait">
                   <Routes>
                     <Route path="/" element={<ProjectDesign />} />
                     <Route path="/editor" element={<ProjectEditor />} />
                   </Routes>
                 </AnimatePresence>
               </UnifiedProjectProvider>
             } 
           />
         </Routes>
       </BrowserRouter>
     );
   }
   ```

7. **Refactor Existing Components**
   - Update components to use the new unified context
   - Replace existing provider usage with the unified provider
   - Ensure backward compatibility during transition
   - Add performance monitoring instrumentation:
   ```tsx
   // Example component refactoring
   import { useUnifiedProject } from '../providers/UnifiedProjectProvider';
   
   function ProjectHeader() {
     const { project, loading } = useUnifiedProject();
     
     if (loading) return <SkeletonLoader />;
     
     return (
       <header>
         <h1>{project?.name}</h1>
         {/* Other header content */}
       </header>
     );
   }
   ```

8. **Implement Performance Monitoring**
   - Add navigation timing metrics collection
   - Track API call frequency before and after implementation
   - Monitor component render counts during navigation
   - Implement user-centric performance metrics:
   ```tsx
   // Performance monitoring utility
   const trackNavigation = (from: string, to: string) => {
     const startTime = performance.now();
     
     return () => {
       const duration = performance.now() - startTime;
       console.log(`Navigation from ${from} to ${to}: ${duration}ms`);
       
       // Send to analytics
       analytics.track('navigation_performance', {
         from,
         to,
         duration,
         timestamp: new Date().toISOString()
       });
     };
   };
   
   // Usage in navigation components
   const navigate = useNavigate();
   const goToEditor = () => {
     const endTracking = trackNavigation('project', 'editor');
     navigate(`/project/${id}/editor`);
     // Call endTracking in useEffect after navigation completes
   };
   ```

9. **Testing and Validation**
   - Implement unit tests for the UnifiedProjectProvider
   - Add integration tests for navigation scenarios
   - Create performance benchmarks to validate improvements
   - Test across different network conditions and device types

# Test Strategy:
## Test Strategy

1. **Unit Testing**
   - Test the UnifiedProjectProvider in isolation:
     - Verify context values are correctly initialized
     - Test cache hit/miss logic with mocked data
     - Validate error handling for API failures
     - Test state updates through provider methods
   - Create test cases for all public methods and hooks:
   ```tsx
   // Example test for useUnifiedProject hook
   test('useUnifiedProject should throw error when used outside provider', () => {
     const renderHook = () => {
       useUnifiedProject();
     };
     
     expect(renderHook).toThrow('useUnifiedProject must be used within a UnifiedProjectProvider');
   });
   
   test('useUnifiedProject should return project data when available', async () => {
     const mockProject = { id: '123', name: 'Test Project' };
     
     // Mock API responses
     jest.spyOn(global, 'fetch').mockImplementation(() => 
       Promise.resolve({
         json: () => Promise.resolve(mockProject),
         ok: true
       } as Response)
     );
     
     const { result, waitForNextUpdate } = renderHook(() => useUnifiedProject(), {
       wrapper: ({ children }) => (
         <MemoryRouter initialEntries={['/project/123']}>
           <Route path="/project/:id">
             <UnifiedProjectProvider>{children}</UnifiedProjectProvider>
           </Route>
         </MemoryRouter>
       )
     });
     
     expect(result.current.loading).toBe(true);
     await waitForNextUpdate();
     
     expect(result.current.loading).toBe(false);
     expect(result.current.project).toEqual(mockProject);
   });
   ```

2. **Integration Testing**
   - Test navigation between Project Design and Editor pages:
     - Verify components don't remount unnecessarily
     - Validate state persistence between routes
     - Test that API calls are reduced on navigation
     - Ensure UI doesn't flash or reset during transitions
   - Create test scenarios for different navigation patterns:
   ```tsx
   test('navigating between project and editor should maintain state', async () => {
     // Setup test environment
     const { getByText, queryByTestId } = render(
       <MemoryRouter initialEntries={['/project/123']}>
         <App />
       </MemoryRouter>
     );
     
     // Wait for initial load
     await waitFor(() => expect(queryByTestId('loading-indicator')).not.toBeInTheDocument());
     
     // Track API call count
     const fetchSpy = jest.spyOn(global, 'fetch');
     const initialCallCount = fetchSpy.mock.calls.length;
     
     // Navigate to editor
     fireEvent.click(getByText('Open Editor'));
     
     // Verify navigation occurred
     expect(window.location.pathname).toBe('/project/123/editor');
     
     // Verify no additional API calls for project data
     expect(fetchSpy.mock.calls.length).toBe(initialCallCount);
     
     // Verify project data is still available
     expect(getByText('Test Project')).toBeInTheDocument();
   });
   ```

3. **Performance Testing**
   - Measure and validate navigation performance metrics:
     - Navigation time between routes (target: <100ms)
     - API call reduction (target: 50% fewer calls)
     - Component render count during navigation
     - Memory usage during navigation
   - Use React DevTools and Performance API for measurements:
   ```javascript
   // Performance test script
   const runNavigationTest = async () => {
     // Setup performance observers
     const navObserver = new PerformanceObserver((list) => {
       const entries = list.getEntries();
       console.table(entries.map(entry => ({
         name: entry.name,
         duration: entry.duration.toFixed(2) + 'ms',
         startTime: entry.startTime.toFixed(2) + 'ms'
       })));
     });
     navObserver.observe({ type: 'navigation', buffered: true });
     
     // Navigate to project page
     await page.goto('http://localhost:3000/project/123');
     await page.waitForSelector('[data-testid="project-loaded"]');
     
     // Measure navigation to editor
     await page.evaluate(() => {
       performance.mark('nav-start');
     });
     
     await page.click('[data-testid="editor-link"]');
     await page.waitForSelector('[data-testid="editor-loaded"]');
     
     await page.evaluate(() => {
       performance.mark('nav-end');
       performance.measure('project-to-editor', 'nav-start', 'nav-end');
     });
     
     // Get results
     const metrics = await page.evaluate(() => {
       const entries = performance.getEntriesByType('measure');
       return entries.map(entry => ({
         name: entry.name,
         duration: entry.duration
       }));
     });
     
     expect(metrics[0].duration).toBeLessThan(100); // Target: <100ms
   };
   ```

4. **User Experience Testing**
   - Conduct user testing to validate perceived performance:
     - Test with different network conditions (fast, slow, intermittent)
     - Validate absence of visible refresh states
     - Test with different device types (desktop, mobile, tablet)
     - Measure user satisfaction with navigation experience
   - Create test scenarios that mimic real user workflows:
   ```
   Test Scenario: Project Design to Editor Workflow
   
   1. User logs in and navigates to project list
   2. User selects an existing project
   3. User reviews project design page for 30 seconds
   4. User clicks "Open Editor" button
   5. User makes changes in the editor
   6. User navigates back to project design page
   7. User returns to editor
   
   Expected Results:
   - Navigation between pages should be near-instantaneous (<100ms)
   - No visible loading states or UI flashes during navigation
   - Project data should be consistent between pages
   - No duplicate API calls should be made for the same data
   ```

5. **Regression Testing**
   - Ensure existing functionality remains intact:
     - Test all project operations (create, read, update, delete)
     - Verify security settings are properly applied
     - Test collaboration features still work correctly
     - Validate that all UI components render correctly
   - Create automated tests for critical paths:
   ```tsx
   test('project operations should work with unified provider', async () => {
     // Setup test environment with unified provider
     const { getByText, getByLabelText } = render(
       <UnifiedProjectProvider>
         <ProjectOperations />
       </UnifiedProjectProvider>
     );
     
     // Test project update
     fireEvent.click(getByText('Edit Project'));
     fireEvent.change(getByLabelText('Project Name'), {
       target: { value: 'Updated Project Name' }
     });
     fireEvent.click(getByText('Save'));
     
     // Verify update was successful
     await waitFor(() => {
       expect(getByText('Project updated successfully')).toBeInTheDocument();
       expect(getByText('Updated Project Name')).toBeInTheDocument();
     });
   });
   ```

6. **Deployment Testing**
   - Test the implementation in staging environment:
     - Verify performance metrics match development environment
     - Test with production-like data volumes
     - Validate caching behavior in production configuration
     - Monitor for any unexpected errors or performance issues
   - Create deployment validation checklist:
   ```
   Deployment Validation Checklist:
   
   1. Navigation time between Project and Editor pages is <100ms
   2. API call count reduced by at least 50% compared to baseline
   3. No visible loading states during navigation
   4. Memory usage remains stable during extended navigation sessions
   5. Cache hit rate exceeds 70% for project data
   6. All existing functionality works correctly
   7. Performance metrics are being correctly logged to monitoring system
   ```

# Subtasks:
## 1. Analyze Current Context Provider Architecture [done]
### Dependencies: None
### Description: Identify existing context providers, document state management approach, and measure current navigation performance metrics.
### Details:
Examine the ProjectProvider and SecurityProvider implementations to understand their structure and data flow. Document how state is currently managed between pages. Create a detailed map of component remounting issues during navigation between project design and editor pages. Establish performance baselines by measuring navigation times, component render counts, and API call frequency.
<info added on 2025-08-28T02:47:10.785Z>
Analysis completed successfully. Created comprehensive documentation in docs/root-cause-analysis-reports/context-provider-analysis-2025-01-28.md covering ProjectProvider and SecurityProvider implementations, state management conflicts, and navigation flow issues. Developed navigationMetrics.ts utility for performance tracking. Measured baseline performance metrics: Editor→Design navigation takes 200-300ms due to ProjectProvider heavy initialization, while Design→Editor is faster at 100-150ms. Root cause confirmed as context provider mismatch causing unnecessary component tree remounting during navigation transitions.
</info added on 2025-08-28T02:47:10.785Z>

## 2. Design and Implement UnifiedProjectProvider [done]
### Dependencies: 28.1
### Description: Create a new context provider that combines project and security data management to prevent remounting issues.
### Details:
Develop the UnifiedProjectProvider component that combines functionality from existing providers. Implement the provider context with proper TypeScript typing. Create a custom hook (useUnifiedProject) for consuming the context. Ensure the provider handles loading states, error conditions, and provides methods for data refreshing and updates.
<info added on 2025-08-28T02:52:59.481Z>
Implementation completed successfully. UnifiedProjectProvider fully operational with comprehensive feature set including unified state management, performance optimizations, error handling, and test coverage. Component ready for production deployment and state caching implementation.Task has been updated with implementation completion details. The UnifiedProjectProvider is now ready for the next phase of state caching implementation.
</info added on 2025-08-28T02:52:59.481Z>

## 3. Implement State Caching Mechanism [done]
### Dependencies: 28.2
### Description: Create a caching system to preserve state during navigation and reduce unnecessary API calls.
### Details:
Implement a project state cache using React Context and localStorage for persistence. Create cache invalidation strategies based on data staleness and project updates. Add cache hit/miss tracking for performance monitoring. Consider implementing React Query or SWR for advanced caching capabilities with automatic revalidation.

## 4. Update Router Configuration [done]
### Dependencies: 28.2, 28.3
### Description: Modify the application router to use the UnifiedProjectProvider for both project routes.
### Details:
Update the router configuration to wrap both /project/{id} and /project/{id}/editor routes with the UnifiedProjectProvider. Implement route transitions with AnimatePresence or similar libraries for smoother UX. Configure the router to use shallow routing when possible to preserve state. Ensure the provider is mounted only once for both routes.

## 5. Refactor Components and Validate Performance [done]
### Dependencies: 28.2, 28.3, 28.4
### Description: Update existing components to use the unified context and validate performance improvements.
### Details:
Refactor components that currently use ProjectProvider or SecurityProvider to use the new UnifiedProjectProvider. Implement performance monitoring to track navigation timing, API call frequency, and component render counts. Add skeleton loaders for perceived performance improvement during data loading. Compare performance metrics before and after implementation to validate improvements.

