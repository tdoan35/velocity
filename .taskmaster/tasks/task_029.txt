# Task ID: 29
# Title: Implement Real-Time Preview Orchestration Service
# Status: pending
# Dependencies: 4, 27, 28
# Priority: high
# Description: Develop a container-based orchestration service on Fly.io that manages ephemeral preview environments with real-time WebSocket communication to replace the batch-based Appetize.io preview system.
# Details:
## Implementation Details

1. **Orchestration Service Architecture**
   - Create a new microservice on Fly.io using Node.js and TypeScript
   - Implement container lifecycle management with the Fly.io API
   - Design a scalable architecture that supports multiple concurrent preview sessions
   - Develop resource allocation and cleanup strategies for ephemeral environments
   ```typescript
   // src/services/container-manager.ts
   export class ContainerManager {
     async createPreviewContainer(projectId: string, userId: string): Promise<ContainerSession> {
       // Provision container with project context
       // Return connection details and session token
     }
     
     async destroyContainer(sessionId: string): Promise<void> {
       // Clean up resources when preview session ends
     }
   }
   ```

2. **Real-Time Communication Layer**
   - Implement WebSocket server using Supabase Realtime
   - Create bidirectional communication channels between editor and preview containers
   - Design efficient message protocol for code changes and preview updates
   - Implement connection management with heartbeat and reconnection logic
   ```typescript
   // src/services/realtime-service.ts
   export class RealtimeService {
     async broadcastCodeChange(sessionId: string, fileChanges: FileChange[]): Promise<void> {
       // Send code changes to preview container
       await this.supabase.from('realtime:code_changes')
         .insert({ sessionId, changes: fileChanges, timestamp: new Date() });
     }
     
     subscribeToPreviewUpdates(sessionId: string, callback: (update: PreviewUpdate) => void): Subscription {
       // Listen for preview container status updates
       return this.supabase
         .channel(`preview:${sessionId}`)
         .on('*', callback)
         .subscribe();
     }
   }
   ```

3. **Preview Container Implementation**
   - Create Docker container template for React Native/web preview environments
   - Implement hot-reloading mechanism that applies code changes without full rebuilds
   - Develop file system watcher and incremental build pipeline
   - Configure container networking for secure communication with orchestration service
   ```dockerfile
   # Dockerfile.preview
   FROM node:18-alpine
   
   WORKDIR /app
   
   # Install dependencies for hot reloading
   RUN npm install -g metro react-native-cli
   
   # Copy runtime scripts
   COPY ./runtime /app/runtime
   
   # Entry point that connects to orchestration service
   ENTRYPOINT ["node", "/app/runtime/bootstrap.js"]
   ```

4. **Database Schema Migration**
   - Design and implement new database tables for preview sessions
   - Create migration scripts for transitioning from Appetize.io to Fly.io system
   - Implement data models for container sessions, project configurations, and user preferences
   ```sql
   -- migrations/preview_system_v2.sql
   CREATE TABLE preview_sessions (
     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
     project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
     user_id UUID REFERENCES auth.users(id),
     container_id TEXT NOT NULL,
     status TEXT NOT NULL,
     created_at TIMESTAMPTZ DEFAULT NOW(),
     last_activity TIMESTAMPTZ DEFAULT NOW(),
     config JSONB
   );
   
   CREATE INDEX idx_preview_sessions_project ON preview_sessions(project_id);
   CREATE INDEX idx_preview_sessions_user ON preview_sessions(user_id);
   ```

5. **API Integration Layer**
   - Develop RESTful API endpoints for preview session management
   - Implement authentication and authorization for secure container access
   - Create session pooling mechanism for improved performance
   - Design rate limiting and resource quota enforcement
   ```typescript
   // src/api/preview-controller.ts
   export class PreviewController {
     @Post('/api/preview/sessions')
     async createSession(req: AuthenticatedRequest): Promise<PreviewSession> {
       const { projectId, deviceType, options } = req.body;
       // Validate user has access to project
       // Create container and return session details
     }
     
     @Delete('/api/preview/sessions/:sessionId')
     async terminateSession(req: AuthenticatedRequest): Promise<void> {
       const { sessionId } = req.params;
       // Validate ownership and terminate container
     }
   }
   ```

6. **Frontend Integration**
   - Update Editor component to connect to new preview system
   - Implement real-time preview panel with status indicators
   - Create preview configuration UI for device selection and options
   - Develop error handling and fallback mechanisms
   ```tsx
   // src/components/PreviewPanel.tsx
   export const PreviewPanel: React.FC<PreviewPanelProps> = ({ projectId }) => {
     const [session, setSession] = useState<PreviewSession | null>(null);
     const [status, setStatus] = useState<PreviewStatus>('initializing');
     
     useEffect(() => {
       // Initialize preview session
       // Subscribe to real-time updates
       return () => {
         // Cleanup session on unmount
       };
     }, [projectId]);
     
     // Render preview iframe or status indicators
   };
   ```

7. **Monitoring and Observability**
   - Implement comprehensive logging throughout the preview system
   - Set up metrics collection for container performance and resource usage
   - Create dashboards for system health monitoring
   - Implement alerting for critical failures
   ```typescript
   // src/services/monitoring.ts
   export class PreviewMonitoring {
     recordSessionCreation(sessionId: string, projectId: string): void {
       // Log session creation and track metrics
     }
     
     recordCodeChangeLatency(sessionId: string, latencyMs: number): void {
       // Track performance metrics for hot reloading
     }
   }
   ```

8. **Phased Rollout Strategy**
   - Implement feature flags for gradual transition from Appetize.io
   - Create fallback mechanisms to ensure service continuity
   - Design A/B testing framework to compare performance
   - Develop migration utilities for existing projects

# Test Strategy:
## Test Strategy

1. **Unit Testing Core Components**
   - Test container lifecycle management functions with mocked Fly.io API
   - Validate WebSocket communication protocol with simulated clients
   - Test database schema and migrations with isolated test database
   - Verify authentication and authorization logic for container access
   - Test error handling and recovery mechanisms

2. **Integration Testing**
   - Set up test environment with actual Fly.io containers
   - Validate end-to-end preview creation and termination flows
   - Test real-time code synchronization between editor and preview
   - Verify database consistency during normal operations and failure scenarios
   - Test concurrent user scenarios with multiple active preview sessions

3. **Performance Testing**
   - Measure container startup time and compare with Appetize.io baseline
   - Benchmark code change to preview update latency under various conditions
   - Test system under load with simulated concurrent users
   - Measure resource utilization and identify optimization opportunities
   - Validate session pooling effectiveness for reducing startup times

4. **Reliability Testing**
   - Simulate network failures and verify reconnection behavior
   - Test container recovery after crashes or unexpected terminations
   - Validate data consistency during service restarts
   - Test graceful degradation under resource constraints
   - Verify cleanup of orphaned resources

5. **Security Testing**
   - Perform penetration testing on container isolation
   - Validate authentication and authorization for all API endpoints
   - Test secure WebSocket communication with proper encryption
   - Verify secure storage of sensitive configuration data
   - Test rate limiting and DDoS protection mechanisms

6. **User Acceptance Testing**
   - Create test scenarios for different user personas and workflows
   - Compare user experience metrics between old and new preview systems
   - Validate device simulation fidelity across different platforms
   - Test accessibility and usability of preview configuration UI
   - Gather feedback on hot-reloading performance and reliability

7. **Monitoring Validation**
   - Verify all key metrics are properly collected and displayed
   - Test alerting mechanisms with simulated failure scenarios
   - Validate log aggregation and search functionality
   - Test dashboard visualizations for accuracy and usefulness
   - Verify that performance anomalies are properly detected

# Subtasks:
## 1. Develop Container Lifecycle Management System [pending]
### Dependencies: None
### Description: Create the core container management service that handles provisioning, monitoring, and termination of preview environments on Fly.io.
### Details:
Implement the ContainerManager class with methods for container lifecycle operations. Create TypeScript interfaces for container configurations and session data. Develop resource allocation algorithms to optimize container distribution. Implement automatic cleanup for inactive sessions. Create monitoring hooks for container health and performance metrics. Use the Fly.io API to manage container deployments programmatically.
<info added on 2025-08-29T08:10:14.147Z>
First, read and review the complete real-time preview implementation plan located at .docs/implementation-plans/real-time-preview-implementation-plan.md to understand the architectural overview, component specifications, and phased implementation approach. This document contains the definitive specifications for the orchestration service and must be thoroughly understood before proceeding with implementation. After reviewing the plan, focus specifically on Section 4.1 (Orchestrator Service) to understand the exact requirements, interfaces, and design patterns that must be followed for the ContainerManager class implementation. Ensure that the implementation aligns with the overall system architecture, WebSocket communication patterns, and database schema defined in the plan. The container lifecycle management system should be implemented as a component of the larger orchestration service, not as a standalone system.
</info added on 2025-08-29T08:10:14.147Z>

## 9. Set up Project Structure and Organization [pending]
### Dependencies: None
### Description: Create the recommended orchestrator/ directory structure from the implementation plan
### Details:
- Create orchestrator/ top-level directory
- Set up orchestrator/src/ for Node.js service code
- Create orchestrator/preview-container/ for Docker assets
- Add orchestrator/fly.toml for deployment configuration
- Organize API routes, services, and container entrypoint logic
- Update project documentation to reflect new structure

## 2. Implement Real-Time WebSocket Communication Layer [pending]
### Dependencies: 29.1
### Description: Build a bidirectional WebSocket communication system using Supabase Realtime to enable instant code updates between editor and preview environments.
### Details:
Develop the RealtimeService class to manage WebSocket connections. Implement message protocol for code changes, preview updates, and system events. Create connection management with heartbeat and reconnection logic. Optimize message payload size for performance. Implement secure authentication for WebSocket connections. Add support for binary data transmission for asset updates.
<info added on 2025-08-29T08:12:16.142Z>
Successfully updated subtask 29.2 to include the requirement to review the implementation plan document before beginning WebSocket development.
</info added on 2025-08-29T08:12:16.142Z>

## 3. Create Preview Container Templates and Hot-Reloading System [pending]
### Dependencies: 29.1, 29.2
### Description: Develop Docker container templates for React Native and web preview environments with hot-reloading capabilities that apply code changes without full rebuilds.
### Details:
Create Dockerfile templates for different project types (React, React Native, Vue, etc.). Implement a file system watcher to detect code changes. Develop an incremental build pipeline that minimizes rebuild time. Configure container networking for secure communication. Implement hot-reloading mechanisms that preserve application state. Create bootstrap scripts that connect to the orchestration service on startup.
<info added on 2025-08-29T08:12:35.942Z>
Based on the user request, I need to add information about reviewing the implementation plan document before proceeding with the container template implementation. Here is the new text to append:

Before implementing the container templates, first review the .docs\implementation-plans\real-time-preview-implementation-plan.md document which contains the complete architectural specifications that must be followed. Pay special attention to Section 4.2 (Preview Container) which provides detailed specifications for the Docker container structure, entrypoint.js logic, and the exact software components that must be included. Also review Section 3 (Recommended Project Structure) to understand where the preview-container directory should be placed and how it integrates with the overall system architecture. All implementation work must strictly adhere to the specifications outlined in this architectural document.
</info added on 2025-08-29T08:12:35.942Z>

## 4. Design and Implement Preview Session Database Schema [pending]
### Dependencies: None
### Description: Create the database schema and models for preview sessions, including tables for container sessions, project configurations, and user preferences.
### Details:
Design database tables for preview sessions with appropriate relationships. Create migration scripts from Appetize.io to the new Fly.io system. Implement data models and TypeORM entities for container sessions. Add indexes for performance optimization. Develop database access layer with proper error handling. Implement data validation and sanitization for user inputs.
<info added on 2025-08-29T08:12:52.043Z>
Review the .docs/implementation-plans/real-time-preview-implementation-plan.md document before implementing any database schema components. This document contains the comprehensive database migration strategy and exact schema specifications required for transitioning from Appetize.io to the container-based preview system. Reference Section 5 (Database Schema Changes) specifically for the precise migration SQL statements, preview_sessions table structure, column specifications, data types, constraints, and indexes. The implementation must strictly adhere to the migration strategy outlined in this document to ensure compatibility with the existing system and proper data migration. All table designs, entity relationships, and database access patterns should align with the specifications provided in the implementation plan document.
</info added on 2025-08-29T08:12:52.043Z>

## 5. Develop API Integration and Frontend Components [pending]
### Dependencies: 29.1, 29.2, 29.3, 29.4
### Description: Create RESTful API endpoints for preview session management and update the frontend components to integrate with the new preview system.
### Details:
Implement RESTful API controllers for preview session management. Create authentication middleware for secure container access. Develop session pooling for improved performance. Update the Editor component to connect to the new preview system. Implement the PreviewPanel component with real-time status indicators. Create configuration UI for device selection and preview options. Develop error handling and fallback mechanisms for preview failures.
<info added on 2025-08-29T08:13:10.880Z>
Before beginning API and frontend implementation, first read and thoroughly analyze the .docs\implementation-plans\real-time-preview-implementation-plan.md document to understand the complete system architecture. Focus specifically on Section 4.1 (Orchestrator Service) for precise API endpoint specifications including request/response formats, authentication requirements, and session management protocols. Review Section 4.3 (Frontend Client) for detailed ProjectEditor integration requirements, component communication patterns, and state management approach. Study Section 6 (Phased Implementation Plan) to follow the correct sequence for frontend integration and deployment phases. All API controllers, authentication middleware, session pooling logic, Editor component updates, PreviewPanel implementation, configuration UI, and error handling must strictly adhere to the architectural patterns, interface contracts, and implementation phases defined in this comprehensive plan.
</info added on 2025-08-29T08:13:10.880Z>

## 6. Set up CI/CD Pipeline and Container Registry [pending]
### Dependencies: None
### Description: Implement GitHub Actions workflow for building and pushing Preview Container images to GitHub Container Registry (GHCR)
### Details:
- Create GitHub Actions workflow for automated container builds
- Configure GHCR authentication and image pushing
- Set up container versioning and tagging strategy
- Test automated deployment pipeline

## 7. Implement Security Hardening and Resource Limiting [pending]
### Dependencies: 29.1
### Description: Configure container isolation, resource limits, and Fly.io security measures
### Details:
- Configure CPU and memory limits for Fly Machines
- Implement Fly.io private networking and firewall rules
- Set up container isolation policies
- Configure network restrictions (whitelist approach)
- Test security measures and resource constraints

## 8. Implement Cleanup Automation and Monitoring [pending]
### Dependencies: 29.1, 29.4
### Description: Create automated cleanup mechanisms for orphaned containers and implement system monitoring
### Details:
- Implement cron job for orphaned container cleanup
- Create background worker for expired session management
- Set up container resource monitoring and alerting
- Implement session timeout and automatic termination
- Add logging and observability for container lifecycle events

